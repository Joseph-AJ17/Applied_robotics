{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Joseph's applied robotics documentation","text":"<p>Bom Dia!\ud83d\udc4b</p> <p>Here I'll be uploading the tasks of the class and the progress of the final project.</p>"},{"location":"#tasks","title":"Tasks","text":"<p>1.- Examples of robots by morphology</p> <p>2.- ROS2</p> <p>3.- Transform nomenclature</p> <p>4.- Forward kinematics</p> <p>5.- ROS2 services</p> <p>6.- Forward Kinematics for KUKA AN UR ROBOT</p> <p>7.- ROS Custom Interfaces</p> <p>8.- ROS Basics Capstone</p>"},{"location":"#final-project","title":"Final project","text":""},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Tareas/Task_1/","title":"Task 1","text":"<p>Home</p>"},{"location":"Tareas/Task_1/#activity1examples-of-robots-by-morphology","title":"Activity1:Examples of robots by morphology","text":""},{"location":"Tareas/Task_1/#objective","title":"Objective:","text":"<p>Investigate and show examples of real life examples of robots with different morphologies.</p>"},{"location":"Tareas/Task_1/#types-of-robots-based-on-its-morphology","title":"Types of robots based on its morphology","text":""},{"location":"Tareas/Task_1/#1-cartesian-robot-xyz-or-gantry","title":"1.- Cartesian Robot (XYZ or Gantry)","text":"<p>Morphology and motion</p> <ul> <li>Moves along three orthogonal linear axes (X, Y, Z).</li> <li>No primary rotational joints.</li> <li>Simple kinematics, high rigidity, and high positional accuracy.</li> </ul> <p></p> <p>Typical applications</p> <ul> <li>CNC machines</li> <li>3D printing</li> <li>Pick &amp; place systems</li> <li>Material handling</li> </ul> <p>Real-world examples</p> <ul> <li> <p>Xyz Gantry System Gantry Robot Arm Xy Cartesian Robot CNC Gantry</p> <p></p> </li> <li> <p>Cartesian Robot JC-3 Series Long Stroke Model</p> <p></p> </li> </ul>"},{"location":"Tareas/Task_1/#2-cylindrical-robot","title":"2.- Cylindrical Robot","text":"<p>Morphology and motion</p> <p>Cylindrical work envelope.</p> <p>Functions by combining:</p> <ul> <li> <p>1 rotational joint (base rotation).</p> </li> <li> <p>2 linear motions (radial and vertical).</p> <p></p> </li> </ul> <p>Typical applications</p> <ul> <li> <p>Machine loading/unloading.</p> </li> <li> <p>Simple assembly.</p> </li> <li> <p>Material transfer.</p> </li> </ul> <p>Real-world examples</p> <ul> <li> <p>Cylindrical Automation Products</p> <p></p> </li> <li> <p>Unimate 2000 Series Robot</p> <p></p> </li> </ul>"},{"location":"Tareas/Task_1/#3-polar-robot-spherical-robot","title":"3.- Polar Robot (Spherical Robot)","text":"<p>Morphology and motion</p> <p>Spherical work envelope.</p> <p>Combines:</p> <ul> <li> <p>2 rotational joints.</p> </li> <li> <p>1 linear joint.</p> <p></p> </li> </ul> <p>Typical applications</p> <ul> <li> <p>Welding.</p> </li> <li> <p>Die casting.</p> </li> <li> <p>Handling of large components.</p> </li> </ul> <p>Real-world examples</p> <ul> <li> <p>Polar Spherical Robots Midwest Engineered Systems</p> <p></p> </li> <li> <p>Cincinnati Milacron T3 Robot</p> <p></p> </li> </ul>"},{"location":"Tareas/Task_1/#4-articulated-robot-jointed-arm-robot","title":"4.- Articulated Robot (Jointed-Arm Robot)","text":"<p>Act almost like if it was a human arm.</p> <p>Morphology and motion</p> <ul> <li> <p>Composed entirely of rotational joints, this helps to have a similar human arm motion.</p> </li> <li> <p>Typically 6 degrees of freedom (6-DOF).</p> </li> <li> <p>High flexibility and complex reach.</p> <p></p> </li> </ul> <p>Typical applications</p> <ul> <li> <p>Arc and spot welding.</p> </li> <li> <p>Painting.</p> </li> <li> <p>Complex assembly.</p> </li> <li> <p>Collaborative robotics.</p> </li> </ul> <p>Real-world examples</p> <ul> <li> <p>KUKA KR 210</p> <p></p> </li> <li> <p>FANUC M-20iA 20M</p> <p></p> </li> </ul>"},{"location":"Tareas/Task_1/#5-scara-robot-selective-compliance-assembly-robot-arm","title":"5.-SCARA Robot (Selective Compliance Assembly Robot Arm)","text":"<p>Morphology and motion</p> <p>The behaviour of this robot is to be flexible in the horizontal plane (X\u2013Y) and rigid in the vertical direction (Z).</p> <p>Motion configuration:</p> <ul> <li> <p>2 rotational joints in the XY plane.</p> </li> <li> <p>1 linear joint along Z.</p> </li> <li> <p>Compliant in XY, rigid in Z.</p> <p></p> </li> </ul> <p>Typical applications</p> <ul> <li> <p>High-speed assemblies.</p> </li> <li> <p>Electronics manufacturing.</p> </li> <li> <p>Pick &amp; place operations.</p> </li> </ul> <p>Real-world examples</p> <ul> <li> <p>Epson SCARA T6</p> <p></p> </li> <li> <p>Omron-i4 SCARA</p> <p></p> </li> </ul>"},{"location":"Tareas/Task_1/#bibliography","title":"Bibliography","text":"<ul> <li> <p>L-5|Classifications of Robot|Cartesian|SCARA ROBOT|Jointed arm|Cylindrical|spherical|Parallel|ESE</p> <ul> <li>https://www.youtube.com/watch?v=sZaGhhKbP-w</li> </ul> </li> <li> <p>Work envelope of robots</p> <ul> <li>https://electricalelibrary.com/en/2022/01/12/work-envelope-of-robots/</li> </ul> </li> </ul>"},{"location":"Tareas/Task_2/","title":"Task 2","text":"<p>Home</p>"},{"location":"Tareas/Task_2/#activity-2-ros2-topics","title":"Activity 2: ROS2 Topics","text":""},{"location":"Tareas/Task_2/#objective","title":"Objective:","text":"<p>Create 2 nodes from scratch. In the first one you\u2019ll have 1 publisher, and in the second one, 1 publisher &amp; 1 subscriber. </p> <ul> <li> <p>The number_publisher node publishes a number (always the same) on the \u201c/number\u201d topic, with the existing type example_interfaces/msg/Int64.</p> </li> <li> <p>The number_counter node subscribes to the \u201c/number\u201d topic. It keeps a counter variable. Every time a new number is received, it\u2019s added to the counter. The node also has a publisher on the \u201c/number_count\u201d topic. When the counter is updated, the publisher directly publishes the new value on the topic. </p> </li> </ul> <p>A few hints:  - Check what to put into the example_interfaces/msg/Int64 with the \u201cros2 interface show\u201d command line tool.  - It may be easier to do the activity in this order: first create the number_publisher node, check that the publisher is working with \u201cros2 topic\u201d. Then create the number_counter, focus on the subscriber. And finally create the last publisher.  - In the number_counter node, the publisher will publish messages directly from the subscriber callback. </p>"},{"location":"Tareas/Task_2/#1st-code-1-publisher","title":"1st code (1 publisher)","text":"<p>In this code we will create a node that it's only function is to be a publishers, this are nodes that publish messages on topics.</p> <p>In this case our node is \"my publisher\", the topic is \"robot_talk\" (this important to remember despite we will use in the subscriber) that will publish 'R2D2 says number: {msg.data}, mesg.data will increment always 1 number until we interrupt the program.</p> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import String\n\n\nclass myPublisher(Node):\n    def __init__(self):\n        super().__init__(\"my_publisher\")\n        self.get_logger().info(\"My robot is publishing on a topic\")\n        self.counter = 0\n                                              #(type, topic name, queue size)\n        self.publisher_ = self.create_publisher(String, \"robot_talk\", 10)\n        self.create_timer(1.0, self.talk)\n\n    def talk(self):\n        msg = String()\n        msg.data = str(self.counter)\n        self.get_logger().info(f'R2D2 says number: {msg.data}')\n        self.publisher_.publish(msg)\n        self.counter += 1\n\ndef main(args=None):\n    rclpy.init(args=args) \n    publisher_node= myPublisher()\n    rclpy.spin(publisher_node)\n\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Tareas/Task_2/#2nd-code-1-subscriber-and-1-publisher","title":"2nd code (1 subscriber and 1 publisher)","text":"<p>In this code we will have 2 functions the new one is the subscriber that are nodes that receive messages from publishers on topics they subscribe to.</p> <p>Our subscriber and publisher node is called \"Listener\" for the subscriber we will use the \"robot_talk\" because is the name of the topic from the first node.</p> <pre><code>self.subscriber = self.create_subscription(String,\"robot_talk\", self.callback_receive_info,10)\n</code></pre> <p>For our new publisher we will copy and paste the previous code modyfying the names of the variables (don't forget to change the topic name mine will be \"spidey_talk\") and adding a few more lines that are the key for the publisher to accomplish the objective.</p> <p>The objective is \"The node also has a publisher on the \u201c/number_count\u201d topic. When the counter is updated, the publisher directly publishes the new value on the topic.\" so for this we need to 3 new lines:</p> <p>On the function \"init\" of the class to add the new message for the publisher</p> <pre><code>self.mensaje_a_decir = \"\" #new to add the new message for the publisher\n</code></pre> <p>On the function of  \"callback_receive_info\"to  equal our previous to message to the new one, we add data so ros don't crash</p> <p><pre><code>self.mensaje_a_decir = msg_que_escucho.data #new to equal our previous to message to the new one, we add data so ros don't crash\n</code></pre> This is not a necessary line but is to see the information that is publishing the  node \"Listener\" withput open a third terminal, we add it on the function \"talk\" of the class.</p> <p><pre><code>self.get_logger().info(\"Mensaje publicado desde el nodo 2: \" + msg_publicador.data) #new to see the information that is publishing the  node \"Listener\" withput open a third terminal\n</code></pre> Here is the complete code:</p> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import String\n\n\nclass mySubscriber(Node):\n    def __init__(self):\n        super().__init__(\"Listener\") \n        self.subscriber = self.create_subscription(String,\"robot_talk\", self.callback_receive_info,10)\n                                                    # type, topic name, callback function, queue size\n        self.publisher_ = self.create_publisher(String, \"spidey_talk\", 10) #vuelvo a rear nuevo publicador y cambio topic para no mezclar info\n        self.create_timer(1.0, self.talk)\n        self.mensaje_a_decir = \"\"\n\n    def callback_receive_info(self, msg_que_escucho: String): #its receiving a msg of type String\n        self.get_logger().info(msg_que_escucho.data) #print the data field\n        self.mensaje_a_decir = msg_que_escucho.data #pongo data porque sino explota\n\n    def talk(self):\n        msg_publicador = String()\n        msg_publicador.data = self.mensaje_a_decir\n        self.publisher_.publish(msg_publicador)\n        self.get_logger().info(\"Mensaje publicado desde el nodo 2: \" + msg_publicador.data)\n\ndef main(args=None):\n    rclpy.init(args=args) \n    subscriber_node= mySubscriber()\n    rclpy.spin(subscriber_node)\n    rclpy.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Tareas/Task_2/#results","title":"Results","text":"<p>To see the results we will have to open a new terminal from \"ubuntu\" to work on ros.</p> <p>After we will have to go to our carpets with cd and then install bash so ros works.</p> <p><pre><code>cd \"name of your workspace\"\nsource install/setup.bash\n</code></pre> Then every time we make a change to our program we will use the next line to compile our codes:</p> <p><pre><code>colcon build\n</code></pre> This are the main steps for ros to work after we will use the command \"ros2 run\" , followed by the name of your package and the name of your node to run the code or in this case the node we need to work.</p> <p><pre><code>ros2 run myrobot_pkg publisher\n</code></pre> </p> <p>We will see this on the terminal.</p> <p>We need to open a new terminal to see that the subscriber and the new publisher are working, we repeat the previus process to acces to our topic we just need to change the name of our node (my case subscriber)</p> <p></p> <p>We can see that ir prints both messages we wanted. We can also open a third terminal to see the messages that is sending our new publisher with the new topic, repeating again the same steps except for the last one, for this will use \"topic echo\" to see the message of the new publisher called \"spider_talker\".</p> <p><pre><code>ros2 topic echo talk spidey_talk\n</code></pre> </p> <p>Finally we can see the graph of the communication flow by writing the next on a necessary third terminal,</p> <pre><code>rqt graph\n</code></pre> <p>It'll automatically open a program to show the  graph asked on the objectives.</p> <p></p> <p>Here are the four windows that shows all that was asked on the objectives.</p> <p></p>"},{"location":"Tareas/Task_3/","title":"Task 3","text":"<p>Home</p>"},{"location":"Tareas/Task_3/#activity-3-transform-nomenclature","title":"Activity 3: Transform nomenclature","text":""},{"location":"Tareas/Task_3/#objective","title":"Objective:","text":"<p>Write the correct nomenclature for the frame transformations, in the attached PDF.</p>"},{"location":"Tareas/Task_3/#1st-exercise","title":"1st exercise","text":""},{"location":"Tareas/Task_3/#2nd-exercise","title":"2nd exercise","text":""},{"location":"Tareas/Task_3/#3rd-exercise","title":"3rd exercise","text":""},{"location":"Tareas/Task_4/","title":"Task 4","text":"<p>Home</p>"},{"location":"Tareas/Task_4/#forward-kinematics","title":"Forward Kinematics","text":""},{"location":"Tareas/Task_4/#objective","title":"Objective:","text":"<p>Upload the matrix  and DH placement of the frames, for the robots in the pdf</p>"},{"location":"Tareas/Task_4/#how-we-solve-the-matrix-multiplication","title":"How we solve the matrix multiplication","text":"<p>For the following problems, we used Matlab to solve all the matrices. The script calculates the matrices both individually (between each frame) and calculates the homogeneous transformation matrix between frame 0 and the frame associated with the final element of the robot. </p> <p>The Matlab script was the following: </p> <pre><code>%% Denavit\u2013Hartenberg (able Evaluator) \n\n% Computes individual link transforms (A_i) and cumulative transforms T_0_i. \n\n\n\n% Notes: \n\n% - Angles are in radians. \n\n% - This script can be configured for different types of joints. \n\n% -------------------- Local Function: Standard DH homogeneous transform -------------------- \n\nfunction H = dhStandard(a, alpha, d, theta) \n\nct = cos(theta);  st = sin(theta); \n\nca = cos(alpha);  sa = sin(alpha); \n\nH = [ ct, -st*ca,  st*sa, a*ct; \n\n      st,  ct*ca, -ct*sa, a*st; \n\n      0,      sa,     ca,    d; \n\n      0,       0,      0,    1 ]; \n\nend \n\n% -------------------- Local Function -------------------- \n\nclear; clc; \n\n% -------------------- Parameters -------------------- \n\n% Notes: \n\n% - In the case of joints with negligible distance between them, L = 0. \n\nl1 = 0; \n\nl2 = 1; \n\nl3 = 0; \n\nl4 = 1; \n\nl5 = 0; \n\nl6 = 1; \n\n% It is assumed that q = 0 for the initial pose. \n\nq = zeros(6,1); \n\n\n% -------------------- DH Table (Standard) -------------------- \n\n% Columns: a [m], alpha [rad], d [m], theta [rad] \n\nDH = table( ... \n\n    [0;   l2;  0;   0;   0;   0], ... \n\n    [pi/2;pi/2;-pi/2;pi/2;-pi/2;0], ... \n\n    [0;   0;   0;   l4;  0;   l6], ... \n\n    [pi/2+q(1); pi/2+q(2); q(3); q(4); q(5); -pi/2+q(6)], ... \n\n    'VariableNames', {'a','alpha','d','theta'} ); \n\n\nN = height(DH); \n\n\n% -------------------- Compute A_i and T_0_i -------------------- \n\nA = cell(N,1); % A{i} = A_i \n\nT = cell(N,1); % T{i} = T_0_i \n\nTcum = eye(4); \n\nfor i = 1:N \n\n    A{i} = dhStandard(DH.a(i), DH.alpha(i), DH.d(i), DH.theta(i)); \n\n    Tcum = Tcum * A{i}; \n\n    T{i} = Tcum; \n\nend\n\n% -------------------- Display Results -------------------- \n\ndisp(\"=== Evaluated DH Table (Standard DH) ===\"); \n\ndisp(DH); \n\n\nfor i = 1:N \n\n    fprintf(\"\\nA_%d =\\n\", i); \n\n    disp(A{i}); \n\nend \n\nT_0_N = T{end}; \n\ndisp(\"=== T_0_N (end-effector pose) ===\"); \n\ndisp(T_0_N); \n</code></pre>"},{"location":"Tareas/Task_4/#advise","title":"Advise","text":"<p>It is important to note that a link length of 1 was assumed for every link whenever its length could not be considered negligible. Additionally, the script was evaluated using the initial configuration, \ud835\udc5e=0. These assumptions were adopted to keep the focus strictly on the kinematic analysis of the robots and on the systematic generation of Denavit\u2013Hartenberg transformation matrices.</p>"},{"location":"Tareas/Task_4/#1st-exercise","title":"1st exercise","text":""},{"location":"Tareas/Task_4/#original-problem-image","title":"Original problem image:","text":""},{"location":"Tareas/Task_4/#result-planes-origins-axis-links","title":"Result (planes, origins, axis, links):","text":""},{"location":"Tareas/Task_4/#data-table","title":"Data table","text":"L a \u03b1 \u03b8 d 1 \\(l_{1.2}\\) \\(-\\pi/2\\) \\(-\\pi/2 + q_1\\) \\(0\\) 2 \\(0\\) \\(0\\) \\(0\\) \\(l_{1.1}+l_2+q_2\\) \\[ \\textbf{DH after sustitution:  } \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta\\\\ \\hline 1 &amp; -1.5708 &amp; 0 &amp; -1.5708\\\\ 0 &amp; 0 &amp; 2 &amp; 0 \\end{array} \\] \\[ T_1= \\begin{bmatrix} 0  &amp; 0  &amp; 1 &amp; 0\\\\ -1 &amp; 0  &amp; 0 &amp; -1\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{2}T= \\begin{bmatrix} 0  &amp; 0 &amp; 1 &amp; 2\\\\ -1 &amp; 0 &amp; 0 &amp; -1\\\\ 0 &amp; -1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"Tareas/Task_4/#result-matrix-arrays","title":"Result (matrix arrays)","text":"<pre><code>% ===== Tabla DH (despu\u00e9s de sustituir q) ===== \n\n\\[ \n\n\\textbf{Tabla DH (despu\u00e9s de sustituir } q\\textbf{)}= \n\n\\begin{array}{c c c c c} \n\na &amp; \\alpha &amp; d &amp; \\theta &amp; \\text{type}\\\\ \\hline \n\n1 &amp; -1.5708 &amp; 0 &amp; -1.5708 &amp; \\text{R}\\\\ \n\n0 &amp; 0       &amp; 2 &amp; 0       &amp; \\text{P} \n\n\\end{array} \n\n\\] \n\n\n\n% ===== Matrices A_i ===== \n\n\\[ \n\nA_1= \n\n\\begin{bmatrix} \n\n0.0000  &amp; 0.0000  &amp; 1.0000 &amp; 0.0000\\\\ \n\n-1.0000 &amp; 0.0000  &amp; 0.0000 &amp; -1.0000\\\\ \n\n0       &amp; -1.0000 &amp; 0.0000 &amp; 0\\\\ \n\n0       &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_2= \n\n\\begin{bmatrix} \n\n1 &amp; 0 &amp; 0 &amp; 0\\\\ \n\n0 &amp; 1 &amp; 0 &amp; 0\\\\ \n\n0 &amp; 0 &amp; 1 &amp; 2\\\\ \n\n0 &amp; 0 &amp; 0 &amp; 1 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n% ===== T_0_N (pose final) ===== \n\n\\[ \n\nT_{0N}= \n\n\\begin{bmatrix} \n\n0.0000  &amp; 0.0000  &amp; 1.0000 &amp; 2.0000\\\\ \n\n-1.0000 &amp; 0.0000  &amp; 0.0000 &amp; -1.0000\\\\ \n\n0       &amp; -1.0000 &amp; 0.0000 &amp; 0.0000\\\\ \n\n0       &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n</code></pre>"},{"location":"Tareas/Task_4/#2nd-exercise","title":"2nd exercise","text":""},{"location":"Tareas/Task_4/#original-problem-image_1","title":"Original problem image:","text":""},{"location":"Tareas/Task_4/#result-planes-origins-axis-links_1","title":"Result (planes, origins, axis, links):","text":""},{"location":"Tareas/Task_4/#data-table_1","title":"Data table","text":"L a \u03b1 \u03b8 d 1 \\(0\\) \\(\\pi/2\\) \\(\\pi/2\\) \\(l_1 + q_1\\) 2 \\(0\\) \\(\\pi/2\\) \\(\\pi/2\\) \\(l_2 + q_2\\) 3 \\(0\\) \\(\\pi\\) \\(0\\) \\(l_3 + q_3\\) \\[ \\textbf{DH after sustitution:  } \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta &amp;\\\\ \\hline 0 &amp; 1.5708 &amp; 1 &amp; 1.5708 &amp;\\\\ 0 &amp; 1.5708 &amp; 1 &amp; 1.5708 &amp;\\\\ 0 &amp; 3.1416 &amp; 1 &amp; 0 &amp; \\end{array} \\] \\[ T_1= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_3= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; -1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{3}T= \\begin{bmatrix} 0 &amp; -1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; -1 &amp; 1\\\\ 1 &amp; -0 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"Tareas/Task_4/#result-matrix-arrays_1","title":"Result (matrix arrays)","text":"<pre><code>% ===== Tabla DH (despu\u00e9s de sustituir q) ===== \n\n\\[ \n\n\\textbf{Tabla DH (despu\u00e9s de sustituir } q\\textbf{)}= \n\n\\begin{array}{c c c c c} \n\na &amp; \\alpha &amp; d &amp; \\theta &amp; \\text{type}\\\\ \\hline \n\n0 &amp; 1.5708 &amp; 1 &amp; 1.5708 &amp; \\text{P}\\\\ \n\n0 &amp; 1.5708 &amp; 1 &amp; 1.5708 &amp; \\text{P}\\\\ \n\n0 &amp; 3.1416 &amp; 1 &amp; 0      &amp; \\text{P} \n\n\\end{array} \n\n\\] \n\n\n\n% ===== Matrices A_i ===== \n\n\\[ \n\nA_1= \n\n\\begin{bmatrix} \n\n0.0000 &amp; -0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n1.0000 &amp; 0.0000  &amp; -0.0000&amp; 0\\\\ \n\n0      &amp; 1.0000  &amp; 0.0000 &amp; 1.0000\\\\ \n\n0      &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_2= \n\n\\begin{bmatrix} \n\n0.0000 &amp; -0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n1.0000 &amp; 0.0000  &amp; -0.0000&amp; 0\\\\ \n\n0      &amp; 1.0000  &amp; 0.0000 &amp; 1.0000\\\\ \n\n0      &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n\\[ \n\nA_3= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0      &amp; 0\\\\ \n\n0      &amp; -1.0000&amp; -0.0000&amp; 0\\\\ \n\n0      &amp; 0.0000 &amp; -1.0000&amp; 1.0000\\\\ \n\n0      &amp; 0      &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n% ===== T_0_N (pose final) ===== \n\n\\[ \n\nT_{0N}= \n\n\\begin{bmatrix} \n\n-0.0000 &amp; -1.0000 &amp; -0.0000 &amp; 1.0000\\\\ \n\n0.0000  &amp; 0.0000  &amp; -1.0000 &amp; 1.0000\\\\ \n\n1.0000  &amp; -0.0000 &amp; 0.0000  &amp; 1.0000\\\\ \n\n0       &amp; 0       &amp; 0       &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n</code></pre>"},{"location":"Tareas/Task_4/#3rd-exercise","title":"3rd exercise","text":""},{"location":"Tareas/Task_4/#original-problem-image_2","title":"Original problem image:","text":""},{"location":"Tareas/Task_4/#result-planes-origins-axis-links_2","title":"Result (planes, origins, axis, links):","text":""},{"location":"Tareas/Task_4/#data-table_2","title":"Data table","text":"L a \u03b1 \u03b8 d 1 \\(0\\) \\(-\\pi/2\\) \\(q_1\\) \\(l_1\\) 2 \\(l_2\\) \\(0\\) \\(q_2\\) \\(0\\) 3 \\(0\\) \\(\\pi/2\\) \\(\\pi/2+q_3\\) \\(0\\) 4 \\(0\\) \\(-\\pi/2\\) \\(\\pi/2+q_4\\) \\(l_3+l_4\\) 5 \\(0\\) \\(\\pi/2\\) \\(q_5\\) \\(0\\) 6 \\(0\\) \\(0\\) \\(q_6\\) \\(l_5+l_6\\) \\[ \\textbf{DH after sustitution:  } \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta\\\\ \\hline 0 &amp; -1.5708 &amp; 1 &amp; 0\\\\ 1 &amp; 0       &amp; 0 &amp; 0\\\\ 0 &amp; 1.5708  &amp; 0 &amp; 1.5708\\\\ 0 &amp; -1.5708 &amp; 2 &amp; 1.5708\\\\ 0 &amp; 1.5708  &amp; 0 &amp; 0\\\\ 0 &amp; 0       &amp; 2 &amp; 0 \\end{array} \\] \\[ T_1= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_3= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_4= \\begin{bmatrix} 0 &amp; 0 &amp; -1 &amp; 0\\\\ 1 &amp; 0 &amp; 0  &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 2\\\\ 0 &amp; 0  &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_5= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; -1 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_6= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{6}T= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 5\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"Tareas/Task_4/#result-matrix-arrays_2","title":"Result (matrix arrays)","text":"<pre><code>% ===== Tabla DH (despu\u00e9s de sustituir q) ===== \n\n\\[ \n\n\\textbf{Tabla DH (despu\u00e9s de sustituir } q\\textbf{)}= \n\n\\begin{array}{c c c c c} \n\na &amp; \\alpha &amp; d &amp; \\theta &amp; \\text{type}\\\\ \\hline \n\n0 &amp; -1.5708 &amp; 1 &amp; 0      &amp; \\text{R}\\\\ \n\n1 &amp; 0       &amp; 0 &amp; 0      &amp; \\text{R}\\\\ \n\n0 &amp; 1.5708  &amp; 0 &amp; 1.5708 &amp; \\text{R}\\\\ \n\n0 &amp; -1.5708 &amp; 2 &amp; 1.5708 &amp; \\text{R}\\\\ \n\n0 &amp; 1.5708  &amp; 0 &amp; 0      &amp; \\text{R}\\\\ \n\n0 &amp; 0       &amp; 2 &amp; 0      &amp; \\text{R} \n\n\\end{array} \n\n\\] \n\n\n\n% ===== Matrices A_i ===== \n\n\\[ \n\nA_1= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0      &amp; 0\\\\ \n\n0      &amp; 0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n0      &amp; -1.0000&amp; 0.0000 &amp; 1.0000\\\\ \n\n0      &amp; 0      &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_2= \n\n\\begin{bmatrix} \n\n1 &amp; 0 &amp; 0 &amp; 1\\\\ \n\n0 &amp; 1 &amp; 0 &amp; 0\\\\ \n\n0 &amp; 0 &amp; 1 &amp; 0\\\\ \n\n0 &amp; 0 &amp; 0 &amp; 1 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n\\[ \n\nA_3= \n\n\\begin{bmatrix} \n\n0.0000 &amp; -0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n1.0000 &amp; 0.0000  &amp; -0.0000&amp; 0\\\\ \n\n0      &amp; 1.0000  &amp; 0.0000 &amp; 0\\\\ \n\n0      &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_4= \n\n\\begin{bmatrix} \n\n0.0000 &amp; -0.0000 &amp; -1.0000 &amp; 0\\\\ \n\n1.0000 &amp; 0.0000  &amp; 0.0000  &amp; 0\\\\ \n\n0      &amp; -1.0000 &amp; 0.0000  &amp; 2.0000\\\\ \n\n0      &amp; 0       &amp; 0       &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n\\[ \n\nA_5= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0       &amp; 0\\\\ \n\n0      &amp; 0.0000 &amp; -1.0000 &amp; 0\\\\ \n\n0      &amp; 1.0000 &amp; 0.0000  &amp; 0\\\\ \n\n0      &amp; 0      &amp; 0       &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_6= \n\n\\begin{bmatrix} \n\n1 &amp; 0 &amp; 0 &amp; 0\\\\ \n\n0 &amp; 1 &amp; 0 &amp; 0\\\\ \n\n0 &amp; 0 &amp; 1 &amp; 2\\\\ \n\n0 &amp; 0 &amp; 0 &amp; 1 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n% ===== T_0_N (pose final) ===== \n\n\\[ \n\nT_{0N}= \n\n\\begin{bmatrix} \n\n-0.0000 &amp; -0.0000 &amp; 1.0000 &amp; 5.0000\\\\ \n\n1.0000  &amp; 0       &amp; 0.0000 &amp; 0.0000\\\\ \n\n0       &amp; 1.0000  &amp; 0.0000 &amp; 1.0000\\\\ \n\n0       &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n</code></pre>"},{"location":"Tareas/Task_4/#4th-exercise","title":"4th exercise","text":""},{"location":"Tareas/Task_4/#original-problem-image_3","title":"Original problem image:","text":""},{"location":"Tareas/Task_4/#result-planes-origins-axis-links_3","title":"Result (planes, origins, axis, links):","text":""},{"location":"Tareas/Task_4/#data-table_3","title":"Data table","text":"L \\(d_z\\) a \u03b1 \u0398 1 \\(l_1\\) \\(0\\) \\(-\\pi/2\\) \\(q_1\\) 2 \\(0\\) \\(l_2\\) \\(0\\) \\(q_2\\) 3 \\(-l_3\\) \\(0\\) \\(\\pi/2\\) \\(\\pi/2+q_3\\) 4 \\(l_4\\) \\(0\\) \\(-\\pi/2\\) \\(q_4\\) 5 \\(0\\) \\(0\\) \\(\\pi/2\\) \\(-\\pi/2+q_5\\) 6 \\(l_6\\) \\(0\\) \\(0\\) \\(q_6\\) \\[ \\textbf{DH after sustitution:  } \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta\\\\ \\hline 0 &amp; -1.5708 &amp; 1  &amp; 0\\\\ 1 &amp; 0       &amp; 0  &amp; 0\\\\ 0 &amp; 1.5708  &amp; -1 &amp; 1.5708\\\\ 0 &amp; -1.5708 &amp; 1  &amp; 0\\\\ 0 &amp; 1.5708  &amp; 0  &amp; -1.5708\\\\ 0 &amp; 0       &amp; 1  &amp; 0   \\end{array} \\] \\[ T_1= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_3= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; -1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_4= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_5= \\begin{bmatrix} 0 &amp; 0 &amp; -1 &amp; 0\\\\ -1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_6= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{6}T= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 2\\\\ 0 &amp; 1 &amp; 0 &amp; -1\\\\ 0 &amp; 0 &amp; 1 &amp; 2\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"Tareas/Task_4/#result-matrix-arrays_3","title":"Result (matrix arrays)","text":"<pre><code>% ===== Tabla DH (despu\u00e9s de sustituir q) ===== \n\n\\[ \n\n\\textbf{Tabla DH (despu\u00e9s de sustituir } q\\textbf{)}= \n\n\\begin{array}{c c c c c} \n\na &amp; \\alpha &amp; d &amp; \\theta &amp; \\text{type}\\\\ \\hline \n\n0 &amp; -1.5708 &amp; 1  &amp; 0       &amp; \\text{R}\\\\ \n\n1 &amp; 0       &amp; 0  &amp; 0       &amp; \\text{R}\\\\ \n\n0 &amp; 1.5708  &amp; -1 &amp; 1.5708  &amp; \\text{R}\\\\ \n\n0 &amp; -1.5708 &amp; 1  &amp; 0       &amp; \\text{R}\\\\ \n\n0 &amp; 1.5708  &amp; 0  &amp; -1.5708 &amp; \\text{R}\\\\ \n\n0 &amp; 0       &amp; 1  &amp; 0       &amp; \\text{R} \n\n\\end{array} \n\n\\] \n\n\n\n% ===== Matrices A_i ===== \n\n\\[ \n\nA_1= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0      &amp; 0\\\\ \n\n0      &amp; 0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n0      &amp; -1.0000&amp; 0.0000 &amp; 1.0000\\\\ \n\n0      &amp; 0      &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_2= \n\n\\begin{bmatrix} \n\n1 &amp; 0 &amp; 0 &amp; 1\\\\ \n\n0 &amp; 1 &amp; 0 &amp; 0\\\\ \n\n0 &amp; 0 &amp; 1 &amp; 0\\\\ \n\n0 &amp; 0 &amp; 0 &amp; 1 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n\\[ \n\nA_3= \n\n\\begin{bmatrix} \n\n0.0000 &amp; -0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n1.0000 &amp; 0.0000  &amp; -0.0000&amp; 0\\\\ \n\n0      &amp; 1.0000  &amp; 0.0000 &amp; -1.0000\\\\ \n\n0      &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_4= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0      &amp; 0\\\\ \n\n0      &amp; 0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n0      &amp; -1.0000&amp; 0.0000 &amp; 1.0000\\\\ \n\n0      &amp; 0      &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n\\[ \n\nA_5= \n\n\\begin{bmatrix} \n\n0.0000  &amp; 0.0000 &amp; -1.0000 &amp; 0\\\\ \n\n-1.0000 &amp; 0.0000 &amp; -0.0000 &amp; 0\\\\ \n\n0       &amp; 1.0000 &amp; 0.0000  &amp; 0\\\\ \n\n0       &amp; 0      &amp; 0       &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_6= \n\n\\begin{bmatrix} \n\n1 &amp; 0 &amp; 0 &amp; 0\\\\ \n\n0 &amp; 1 &amp; 0 &amp; 0\\\\ \n\n0 &amp; 0 &amp; 1 &amp; 1\\\\ \n\n0 &amp; 0 &amp; 0 &amp; 1 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n% ===== T_0_N (pose final) ===== \n\n\\[ \n\nT_{0N}= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0      &amp; 2.0000\\\\ \n\n0.0000 &amp; 1.0000 &amp; 0      &amp; -1.0000\\\\ \n\n0      &amp; 0      &amp; 1.0000 &amp; 2.0000\\\\ \n\n0      &amp; 0      &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n</code></pre>"},{"location":"Tareas/Task_4/#5th-exercise","title":"5th exercise","text":""},{"location":"Tareas/Task_4/#original-problem-image_4","title":"Original problem image:","text":""},{"location":"Tareas/Task_4/#result-planes-origins-axis-links_4","title":"Result (planes, origins, axis, links):","text":""},{"location":"Tareas/Task_4/#data-table_4","title":"Data table","text":"L \\(d_z\\) a \u03b1 \u03b8 1 \\(0\\) \\(0\\) \\(\\pi/2\\) \\(\\pi/2+q_1\\) 2 \\(0\\) \\(l_2\\) \\(-\\pi/2\\) \\(\\pi/2+q_2\\) 3 \\(0\\) \\(0\\) \\(\\pi/2\\) \\(q_3\\) 4 \\(l_4\\) \\(0\\) \\(\\pi/2\\) \\(q_4\\) 5 \\(0\\) \\(0\\) \\(-\\pi/2\\) \\(q_5\\) 6 \\(l_6\\) \\(0\\) \\(0\\) \\(-\\pi/2+q_6\\) \\[ \\textbf{DH after substitution:  } \\begin{array}{c c c c c} a &amp; \\alpha &amp; d &amp; \\theta\\\\ \\hline 0 &amp; 1.5708  &amp; 0 &amp; 1.5708\\\\ 1 &amp; 1.5708  &amp; 0 &amp; 1.5708\\\\ 0 &amp; -1.5708 &amp; 0 &amp; 0\\\\ 0 &amp; 1.5708  &amp; 1 &amp; 0\\\\ 0 &amp; -1.5708 &amp; 0 &amp; 0\\\\ 0 &amp; 0       &amp; 1 &amp; -1.5708 \\end{array} \\] \\[ T_1= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_2= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 1\\\\ 0 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_3= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_4= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; -1 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ T_5= \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 0\\\\ 0 &amp; -1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\qquad T_6= \\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0\\\\ -1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ ^{0}_{6}T= \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 2\\\\ 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"Tareas/Task_4/#result-matrix-arrays_4","title":"Result (matrix arrays)","text":"<pre><code>% ===== Tabla DH (despu\u00e9s de sustituir q) ===== \n\n\\[ \n\n\\textbf{Tabla DH (despu\u00e9s de sustituir } q\\textbf{)}= \n\n\\begin{array}{c c c c c} \n\na &amp; \\alpha &amp; d &amp; \\theta &amp; \\text{type}\\\\ \\hline \n\n0 &amp; 1.5708  &amp; 0 &amp; 1.5708  &amp; \\text{R}\\\\ \n\n1 &amp; 1.5708  &amp; 0 &amp; 1.5708  &amp; \\text{R}\\\\ \n\n0 &amp; -1.5708 &amp; 0 &amp; 0       &amp; \\text{R}\\\\ \n\n0 &amp; 1.5708  &amp; 1 &amp; 0       &amp; \\text{R}\\\\ \n\n0 &amp; -1.5708 &amp; 0 &amp; 0       &amp; \\text{R}\\\\ \n\n0 &amp; 0       &amp; 1 &amp; -1.5708 &amp; \\text{R} \n\n\\end{array} \n\n\\] \n\n\n\n% ===== Matrices A_i ===== \n\n\\[ \n\nA_1= \n\n\\begin{bmatrix} \n\n0.0000 &amp; -0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n1.0000 &amp; 0.0000  &amp; -0.0000&amp; 0\\\\ \n\n0      &amp; 1.0000  &amp; 0.0000 &amp; 0\\\\ \n\n0      &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_2= \n\n\\begin{bmatrix} \n\n0.0000 &amp; -0.0000 &amp; 1.0000 &amp; 0.0000\\\\ \n\n1.0000 &amp; 0.0000  &amp; -0.0000&amp; 1.0000\\\\ \n\n0      &amp; 1.0000  &amp; 0.0000 &amp; 0\\\\ \n\n0      &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n\\[ \n\nA_3= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0      &amp; 0\\\\ \n\n0      &amp; 0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n0      &amp; -1.0000&amp; 0.0000 &amp; 0\\\\ \n\n0      &amp; 0      &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_4= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0       &amp; 0\\\\ \n\n0      &amp; 0.0000 &amp; -1.0000 &amp; 0\\\\ \n\n0      &amp; 1.0000 &amp; 0.0000  &amp; 1.0000\\\\ \n\n0      &amp; 0      &amp; 0       &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n\\[ \n\nA_5= \n\n\\begin{bmatrix} \n\n1.0000 &amp; 0      &amp; 0      &amp; 0\\\\ \n\n0      &amp; 0.0000 &amp; 1.0000 &amp; 0\\\\ \n\n0      &amp; -1.0000&amp; 0.0000 &amp; 0\\\\ \n\n0      &amp; 0      &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\qquad \n\nA_6= \n\n\\begin{bmatrix} \n\n0.0000  &amp; 1.0000 &amp; 0      &amp; 0\\\\ \n\n-1.0000 &amp; 0.0000 &amp; 0      &amp; 0\\\\ \n\n0       &amp; 0      &amp; 1.0000 &amp; 1.0000\\\\ \n\n0       &amp; 0      &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n\n\n\n% ===== T_0_N (pose final) ===== \n\n\\[ \n\nT_{0N}= \n\n\\begin{bmatrix} \n\n0.0000 &amp; -0.0000 &amp; 1.0000 &amp; 2.0000\\\\ \n\n1.0000 &amp; 0       &amp; -0.0000&amp; -0.0000\\\\ \n\n0      &amp; 1.0000  &amp; 0.0000 &amp; 1.0000\\\\ \n\n0      &amp; 0       &amp; 0      &amp; 1.0000 \n\n\\end{bmatrix} \n\n\\] \n</code></pre>"},{"location":"Tareas/Task_5/","title":"Task 5","text":"<p>Home</p>"},{"location":"Tareas/Task_5/#ros-2-services","title":"Ros 2 Services","text":""},{"location":"Tareas/Task_5/#objective","title":"Objective:","text":"<p>Add a functionality to reset the counter to zero: - Create a service server inside the \u201cnumber_counter\u201d node. - Service name: \u201c/reset_counter\u201d - Service type: example_interfaces/srv/SetBool. Use \u201cros2 interface show\u201d to discover what\u2019s inside! - When the server is called, you check the boolean data from the request. If true, you set the counter variable to 0.</p> <p>We will then call the service directly from the command line.</p>"},{"location":"Tareas/Task_5/#previous-information","title":"Previous information","text":"<p>For this activity I will use the codes that I did on the ROS2 activity or the task_2, because we only need to add a few things and change a bit the logic of the codes.</p>"},{"location":"Tareas/Task_5/#1st-code-my_publisher","title":"1st code (my_publisher)","text":"<p>On this code we will change 2 things and add 1:</p> <ul> <li>Import the data type</li> <li>The type on data we are sending</li> <li>The logic of the counter</li> </ul>"},{"location":"Tareas/Task_5/#import-the-data-type","title":"Import the data type","text":"<p>Int64 is used when we want to transmit 64-bit integer numeric data; for example, if we need to send or receive large numeric values \u200b\u200b(for example, a counter, measurement of some parameter, etc.).</p> <p>In this exercise we are being asked to use integer data type, for that we will import it from the example_interfaces.msg</p> <pre><code>from example_interfaces.msg import Int64\n</code></pre>"},{"location":"Tareas/Task_5/#type-of-data","title":"Type of data","text":"<p>Now that we have the  integer data type we will change that small text on the initialization function to send integer dataso our function can work.</p> <pre><code>self.publisher_ = self.create_publisher(Int64, \"robot_talk\", 10)  # Use Int64 instead of string\n</code></pre>"},{"location":"Tareas/Task_5/#logic-of-the-counter","title":"Logic of the counter","text":"<p>The previous code was adding, but now we want it to send the same data because when using boolean data there are only 1 and 0, so we will change the signs from += to just = to always have the same data</p> <pre><code>self.counter = 1  # El contador ahora solo es igual porque la l\u00f3gica de sumar esta en my_susbscriber\n</code></pre>"},{"location":"Tareas/Task_5/#my_publisher-code","title":"my_publisher code","text":"<p>Here is the complete code:</p> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n\nclass myPublisher(Node):\n    def __init__(self):\n        super().__init__(\"my_publisher\")\n        self.get_logger().info(\"My robot is publishing on a topic\")\n        self.counter = 0\n        self.publisher_ = self.create_publisher(Int64, \"robot_talk\", 10)  # Use Int64 instead of string\n        self.create_timer(1.0, self.talk)\n\n    def talk(self):\n        msg = Int64()\n        msg.data = self.counter  # Publica el contador\n        self.get_logger().info(f'R2D2 says number: {msg.data}')\n        self.publisher_.publish(msg)\n        self.counter = 1  # El contador ahora solo es igual porque la l\u00f3gica de sumar esta en my_susbscriber\n\n    def reset_counter(self):\n        self.counter = 0  # Resetear el contador si el servicio es invocado\n\ndef main(args=None):\n    rclpy.init(args=args)\n    publisher_node = myPublisher()\n    rclpy.spin(publisher_node)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Tareas/Task_5/#2nd-code-my_subscriber","title":"2nd code (my_subscriber)","text":"<p>For this code we will add more things and the change to logic of all the data we were recieving.</p>"},{"location":"Tareas/Task_5/#data-type","title":"Data type","text":"<p>For this exercise we are being asked to use boolean data to use that data we use Setbool.</p> <p>Setbool is used when defining a service that needs to receive a boolean value (True or False) and respond with a confirmation or message. For example, a service is a way to perform actions that require an immediate response, such as turning a device on/off, resetting a counter, or enabling an option.</p> <p>Now at the beginning of the code we will add  the Int64 and Setbool so we can use that data type.</p> <p><pre><code>from example_interfaces.msg import Int64\nfrom example_interfaces.srv import SetBool\n</code></pre> After this we have to change all the data that was on the previous code to Int64 data type.</p> <p>We change the initialization function of subscriber and publisher:</p> <p><pre><code>self.subscriber = self.create_subscription(Int64, \"robot_talk\", self.callback_receive_info, 10)\nself.publisher_ = self.create_publisher(Int64, \"spidey_talk\", 10)\n</code></pre> We change the callback information:</p> <p><pre><code>def callback_receive_info(self, msg_que_escucho: Int64):\n</code></pre> Finally we change the variable msg.publicador to recieve Int64 data on the function talk</p> <pre><code>msg_publicador = Int64()\n</code></pre>"},{"location":"Tareas/Task_5/#create-the-server","title":"Create the server","text":"<p>We will add 2 lines:</p> <ul> <li> <p>self.server_ creates the server and works like the other terms to select the data type, name and function.</p> </li> <li> <p>self.counter to start the counter that will help us to do the reset function.</p> </li> </ul> <pre><code>self.server_ = self.create_service(SetBool, \"/reset_counter\", self.read_bool_callback)\nself.counter = 0  # Begins the counter on 0\n</code></pre>"},{"location":"Tareas/Task_5/#logic-of-adding-on-the-recieved-message","title":"Logic of adding on the recieved message","text":"<p>For this part we will change a small detail on the function def callback_receive_info, so that it adds to what our publisher is sending.</p> <pre><code>self.mensaje_a_decir += msg_que_escucho.data  #Guarda el valor del mensaje recibido\n</code></pre> <p>It's put += because it's linked to the publisher, since now the publisher is worth 1, so I want to keep adding it.</p>"},{"location":"Tareas/Task_5/#create-a-function-to-read-the-boolean-data","title":"Create a function to read the boolean data","text":"<p>For this we will follow the path to create a function, also this will be the function that reset our counter to 0.</p> <pre><code>def read_bool_callback(self, request, response):\n        if request.data:\n            #Resetea el contador como el mensaje a decir\n            self.counter = 0\n            self.mensaje_a_decir = self.counter  #Resetea el valor de mensaje_a_decir\n            response.success = True\n            response.message = \"Contador reseteado a 0\"\n            self.get_logger().info(\"Reseteando contador a 0\")\n        else:\n            response.success = False\n            response.message = \"No se pudo resetear el contador, intenta nuevamente\"\n        return response\n</code></pre> <p>This function resets the counter to 0 and the value of message_to_say when it receives a request with True. If the request is False, it takes no action and returns an error message.</p>"},{"location":"Tareas/Task_5/#my_subscriber-code","title":"my_subscriber code","text":"<p>Here is the complete code:</p> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\nfrom example_interfaces.srv import SetBool\n\nclass mySubscriber(Node):\n    def __init__(self):\n        super().__init__(\"Listener\")\n        self.subscriber = self.create_subscription(Int64, \"robot_talk\", self.callback_receive_info, 10)\n        self.publisher_ = self.create_publisher(Int64, \"spidey_talk\", 10)\n        self.create_timer(1.0, self.talk)\n        self.mensaje_a_decir = 0\n        self.server_ = self.create_service(SetBool, \"/reset_counter\", self.read_bool_callback)\n        self.counter = 0  #Begins the counter on 0\n\n    def callback_receive_info(self, msg_que_escucho: Int64):\n        #Recibe el mensaje como tipo Int64\n        self.get_logger().info(f\"Mensaje recibido: {msg_que_escucho.data}\")\n        self.mensaje_a_decir += msg_que_escucho.data  #Guarda el valor del mensaje recibido\n        #Se pone += porque esta vinculado con el publisher pues haora el publisher vale 1 entonces yo quiero \n        #irlo sumando \n\n    def talk(self):\n        #Publica el valor actualizado del contador\n        msg_publicador = Int64()\n        msg_publicador.data = self.mensaje_a_decir  #Publica el valor entero\n        self.publisher_.publish(msg_publicador)\n        self.get_logger().info(f\"Mensaje publicado: {msg_publicador.data}\")\n        #Eso afecta a lo que voy a publicar porque solo uno hace la cuenta y este publicado nunca la hace\n\n    def read_bool_callback(self, request, response):\n        if request.data:\n            #Resetea el contador como el mensaje a decir\n            self.counter = 0\n            self.mensaje_a_decir = self.counter  #Resetea el valor de mensaje_a_decir\n            response.success = True\n            response.message = \"Contador reseteado a 0\"\n            self.get_logger().info(\"Reseteando contador a 0\")\n        else:\n            response.success = False\n            response.message = \"No se pudo resetear el contador, intenta nuevamente\"\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    subscriber_node = mySubscriber()\n    rclpy.spin(subscriber_node)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Tareas/Task_5/#results","title":"Results","text":"<p>To see the results we need to open 4 ubuntu terminals</p>"},{"location":"Tareas/Task_5/#1st-terminal","title":"1st terminal","text":"<p>Is important to remember that when we open a new terminal we need to move to our folder and install the setup.bash</p> <pre><code>cd \"folder_name\"\nsource install/setup.bash\n</code></pre> <p>After this we will type:</p> <pre><code>ros2 run \"your_package_name\" \"name_entry_point_1stcode\"\n</code></pre> <p></p>"},{"location":"Tareas/Task_5/#2nd-terminal","title":"2nd terminal","text":"<p>Repeat the same process but now we will open our full second code</p> <pre><code>ros2 run \"your_package_name\" \"name_entry_point_2ndcode\"\n</code></pre> <p></p> <p>We can see the received message, which is only 1, since that's what the previous code sends. And the published message, which adds one to the received message to create the counter.</p>"},{"location":"Tareas/Task_5/#3rd-terminal","title":"3rd terminal","text":"<p>Repeat the same process but now we will open our talk of the second code</p> <pre><code>ros2 topic echo \"name_topic\"\n</code></pre> <p></p>"},{"location":"Tareas/Task_5/#4th-terminal","title":"4th terminal","text":"<p>Finally, to perform the reset from what was published, we need to open another terminal and type</p> <pre><code>ros2 service call \"name_service\" example_interfaces/srv/SetBool \"{data: true}\"\n</code></pre> <p></p> <p>Now we can see that in our 2nd terminal the count is reset to 0</p> <p></p> <p>And it also restarts on our 3rd terminal</p> <p></p>"},{"location":"Tareas/Task_5/#graph-the-result","title":"Graph the result","text":"<p>To see the diagram grapg we need to put in a new terminal the following:</p> <pre><code>rqt_graph\n</code></pre> <p>After this we will have to turn off the Dead sinks, tf, Unreachable and Params by clicking on the box. In that way we can see the almost the same image (dependening on the name of your variables) as the one that we have on the activity. Reaching the objective of the activity.</p> <p></p>"},{"location":"Tareas/Task_6/","title":"Task 6","text":"<p>Home</p>"},{"location":"Tareas/Task_6/#forward-kinematics-using-dh-parameters-ur5e-and-kuka-kr16","title":"Forward Kinematics using DH Parameters (UR5e and KUKA KR16)","text":""},{"location":"Tareas/Task_6/#1-introduction","title":"1. Introduction","text":"<ul> <li>UR5e (6-axis collaborative robot)</li> <li>KUKA KR16 (6-axis industrial robot)</li> </ul> <p>Forward kinematics computes the end-effector pose (position and orientation) with respect to the base frame, given:</p> <ul> <li>The robot geometric parameters (link lengths and offsets)</li> <li>The joint variables (joint angles for revolute joints)</li> </ul> <p>The result is typically expressed as a homogeneous transformation matrix:</p> \\[ {}^{0}T_{6}(\\mathbf{q}) = \\begin{bmatrix} {}^{0}R_{6}(\\mathbf{q}) &amp; {}^{0}p_{6}(\\mathbf{q}) \\\\ 0\\;0\\;0 &amp; 1 \\end{bmatrix} \\] <p>where:</p> <ul> <li>\\( {}^{0}R_{6} \\) is a 3\u00d73 rotation matrix</li> <li>\\( {}^{0}p_{6} \\) is a 3\u00d71 position vector</li> <li>\\( \\mathbf{q} = [q_1, q_2, q_3, q_4, q_5, q_6]^T \\)</li> </ul>"},{"location":"Tareas/Task_6/#2-model-1-ur5e-forward-kinematics-dh-table","title":"2. Model 1: UR5e forward kinematics (DH table)","text":""},{"location":"Tareas/Task_6/#21-notes-about-the-ur5e-model","title":"2.1 Notes about the UR5e model","text":"<p>UR5e is a 6-DOF serial manipulator with a 3-DOF wrist. The DH table below uses symbolic geometric parameters \\(L_1 \\dots L_6\\) and joint variables \\(q_1 \\dots q_6\\).</p> <p>Important modeling details:</p> <ul> <li>Angle offsets such as \\(-\\pi/2 + q_2\\) are part of the frame assignment. They shift the zero position of a joint so that the DH frames align with a chosen \u201chome\u201d configuration.</li> <li>Length parameters \\(L_i\\) must be defined in consistent units (all in meters or all in millimeters).</li> <li>The resulting \\( {}^{0}T_{6} \\) depends on the chosen base frame and the end-effector frame definition (tool flange vs TCP).</li> </ul>"},{"location":"Tareas/Task_6/#22-image-placeholder-ur5e-diagram","title":"2.2 Image placeholder (UR5e diagram)","text":"<p>Insert the UR5e kinematic diagram here (before the table):</p> <p></p>"},{"location":"Tareas/Task_6/#23-ur5e-dh-table-latex","title":"2.3 UR5e DH table (LaTeX)","text":"\\[ \\textbf{UR5e DH Parameters}= \\begin{array}{c|c|c|c|c} \\text{Link} &amp; a_i &amp; d_i &amp; \\alpha_i &amp; \\theta_i \\\\ \\hline 1 &amp; 0   &amp; L_1 &amp; \\frac{\\pi}{2}  &amp; q_1 \\\\ 2 &amp; L_1 &amp; 0   &amp; 0                &amp; -\\frac{\\pi}{2}+q_2 \\\\ 3 &amp; L_3 &amp; 0   &amp; 0                &amp; q_3 \\\\ 4 &amp; 0   &amp; L_4 &amp; \\frac{\\pi}{2}  &amp; -\\frac{\\pi}{2}+q_4 \\\\ 5 &amp; 0   &amp; L_5 &amp; -\\frac{\\pi}{2} &amp; q_5 \\\\ 6 &amp; 0   &amp; L_6 &amp; 0                &amp; -\\pi+q_6 \\end{array} \\]"},{"location":"Tareas/Task_6/#24-how-to-compute-the-ur5e-forward-kinematics","title":"2.4 How to compute the UR5e forward kinematics","text":"<ol> <li>Build each \\( {}^{i-1}T_i \\) using the matrix definition in Section 2.2 and the parameters from the table.</li> <li>Substitute joint angles \\(q_i\\) (radians) and link constants \\(L_i\\).</li> <li>Multiply all transforms in order to get \\( {}^{0}T_{6} \\).</li> <li>Extract position and orientation from \\( {}^{0}T_{6} \\).</li> <li>If you have a TCP/tool offset, multiply by \\( {}^{6}T_{TCP} \\).</li> </ol>"},{"location":"Tareas/Task_6/#3-model-2-kuka-kr16-forward-kinematics-dh-like-table","title":"3. Model 2: KUKA KR16 forward kinematics (DH-like table)","text":""},{"location":"Tareas/Task_6/#31-notes-about-the-kr16-model","title":"3.1 Notes about the KR16 model","text":"<p>KUKA KR16 is a 6-DOF industrial manipulator. Many KR-series robots are modeled with a DH (or DH-like) parameterization. The table below uses the symbols:</p> <ul> <li>\\(L_i\\): translational parameter (commonly used as an offset along the z-axis in DH-like models)</li> <li>\\(D2_i\\): translational parameter (commonly used as a distance along the x-axis in DH-like models)</li> <li>\\(\\theta_i\\): joint angle (contains the variable \\(q_i\\) and possible constant offsets)</li> <li>\\(\\alpha_i\\): twist angle between axes</li> </ul> <p>This model is equivalent to the standard DH form if you interpret:</p> <ul> <li>\\(d_i \\leftarrow L_i\\)</li> <li>\\(a_i \\leftarrow D2_i\\)</li> </ul> <p>and use:</p> \\[ {}^{i-1}T_i = R_z(\\theta_i)\\,T_z(L_i)\\,T_x(D2_i)\\,R_x(\\alpha_i) \\] <p>As with the UR5e, constant angle terms (for example \\(\\pi/2\\) shifts) are tied to the chosen reference frames and the definition of the robot \u201czero\u201d configuration.</p>"},{"location":"Tareas/Task_6/#32-image-placeholder-kr16-diagram","title":"3.2 Image placeholder (KR16 diagram)","text":"<p>Insert the KR16 kinematic diagram here (before the table):</p> <p></p>"},{"location":"Tareas/Task_6/#33-kr16-parameter-table-latex","title":"3.3 KR16 parameter table (LaTeX)","text":"\\[ \\textbf{KUKA KR16 Parameters}= \\begin{array}{c|c|c|c|c} \\text{Link} &amp; L_i &amp; D2_i &amp; \\theta_i &amp; \\alpha_i \\\\ \\hline 1 &amp; -L_1      &amp; -L_2 &amp; q_1            &amp; -\\frac{\\pi}{2} \\\\ 2 &amp; 0         &amp; L_3  &amp; \\frac{\\pi}{2}+q_2 &amp; \\pi \\\\ 3 &amp; 0         &amp; 0    &amp; q_3            &amp; \\frac{\\pi}{2} \\\\ 4 &amp; L_4+L_5   &amp; 0    &amp; q_4            &amp; -\\frac{\\pi}{2} \\\\ 5 &amp; 0         &amp; 0    &amp; q_5            &amp; \\frac{\\pi}{2} \\\\ 6 &amp; -L_6      &amp; 0    &amp; q_6            &amp; \\pi \\end{array} \\]"},{"location":"Tareas/Task_6/#34-how-to-compute-the-kr16-forward-kinematics","title":"3.4 How to compute the KR16 forward kinematics","text":"<ol> <li>Use the transform definition \\( {}^{i-1}T_i = R_z(\\theta_i)\\,T_z(L_i)\\,T_x(D2_i)\\,R_x(\\alpha_i) \\).</li> <li>Substitute link constants \\(L_i\\), \\(D2_i\\) and joint variables \\(q_i\\).</li> <li>Multiply the six transforms in order to obtain \\( {}^{0}T_{6} \\).</li> <li>Extract \\( {}^{0}p_{6} \\) and \\( {}^{0}R_{6} \\).</li> <li>Apply any TCP/tool transform if needed.</li> </ol>"},{"location":"Tareas/Task_7/","title":"Task 7","text":"<p>Home</p>"},{"location":"Tareas/Task_7/#ros-custom-interfaces","title":"ROS Custom Interfaces","text":""},{"location":"Tareas/Task_7/#overview","title":"Overview","text":"<p>This activity extends the services workflow by introducing custom ROS 2 interfaces (one <code>.msg</code> and one <code>.srv</code>) and integrating them into a two-node system:</p> <ul> <li>A Battery node simulates the battery level and acts as a service client.</li> <li>An LED panel node exposes a service server (<code>/set_led</code>) and publishes the LED panel state on a topic (<code>/led_panel_state</code>).</li> </ul> <p>Conceptually, the goal is to use a service request to toggle an LED depending on battery state: when the battery becomes empty, an LED is powered ON, and when it becomes full again, it is powered OFF.</p> <p></p>"},{"location":"Tareas/Task_7/#system-architecture","title":"System Architecture","text":"<p>Nodes</p> <ol> <li> <p><code>Battery_node</code> </p> <ul> <li>Service client for: <code>/set_led</code></li> </ul> </li> <li> <p><code>LED_panel_node</code> </p> <ul> <li>Service server for: <code>/set_led</code></li> <li>Topic publisher for: <code>/led_panel_state</code></li> </ul> </li> </ol> <p>Interfaces</p> <ul> <li>Custom service: <code>LEDpanel.srv</code> (used by <code>/set_led</code>)</li> <li>Custom message: <code>BatStatus.msg</code> (used by <code>/led_panel_state</code>)</li> </ul>"},{"location":"Tareas/Task_7/#custom-interfaces","title":"Custom Interfaces","text":"<p>Before implementing the nodes, a dedicated interfaces package (in this case, <code>er_interfaces</code>) is used to define and build the custom service and message types.</p>"},{"location":"Tareas/Task_7/#service-definition-ledpanelsrv","title":"Service definition: <code>LEDpanel.srv</code>","text":"<p>The service definition is designed to represent a 3-LED panel through three boolean request fields and a single boolean response field:</p> <ul> <li>Request</li> <li><code>lbit1</code> (bool): LED 1 command</li> <li><code>lbit2</code> (bool): LED 2 command</li> <li><code>lbit3</code> (bool): LED 3 command</li> <li>Response</li> <li><code>success</code> (bool): confirms whether the request was processed correctly</li> </ul> <p>Is important to consider that request/response field names were written using lowercase letters and without symbols to avoid build/compilation issues in the ROS 2 interface generation pipeline.</p> <pre><code>bool lbit1\nbool lbit2\nbool lbit3\n---\nbool success\n</code></pre>"},{"location":"Tareas/Task_7/#message-definition-batstatusmsg","title":"Message definition: <code>BatStatus.msg</code>","text":"<p>The LED panel state is published as a custom message with three <code>int8</code> fields:</p> <ul> <li><code>led1</code> (int8): LED 1 state (0/1)</li> <li><code>led2</code> (int8): LED 2 state (0/1)</li> <li><code>led3</code> (int8): LED 3 state (0/1)</li> </ul> <pre><code>int8 led1\nint8 led2\nint8 led3\n</code></pre> <p>This representation is intentionally minimal: each LED state is expressed as a numeric bit (0 = OFF, 1 = ON).</p> <p>Finally, to generate and use these interfaces, the <code>.msg</code> and <code>.srv</code> paths must be registered in the interface generation section (<code>rosidl_generate_interfaces(...)</code>) in <code>CMakeLists.txt</code>.</p> <pre><code>rosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/BatStatus.msg\"\n  \"srv/LEDpanel.srv\"\n  #Remaining file paths\n)\n</code></pre>"},{"location":"Tareas/Task_7/#node-1-led-panel-node-service-server-state-publisher","title":"Node 1 \u2014 LED Panel Node (Service Server + State Publisher)","text":"<p>The <code>LED_panel_node</code> is responsible for two roles:</p> <ol> <li>Hosting the <code>/set_led</code> service server (custom type <code>LEDpanel</code>)</li> <li>Publishing the LED panel state on the <code>/led_panel_state</code> topic (custom type <code>BatStatus</code>)</li> </ol> <p>Also, instead of publishing panel state continuously with a timer, this node publishes only when there is a meaningful change (when a service request arrives). This avoids sending redundant messages and keeps the topic output focused on actual state transitions.</p> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom er_interfaces.srv import LEDpanel\nfrom er_interfaces.msg import BatStatus\n\nclass MyPanel(Node):\n    def __init__(self):\n        super().__init__(\"LED_panel_node\") #Only identification\n\n        self.server = self.create_service(LEDpanel,\"set_led\", self.set_status)\n        self.publisher_ = self.create_publisher(BatStatus, \"led_panel_state\", 10)\n\n        self.get_logger().info(\"LEDs Panel ready\")\n\n    def set_status(self, request: LEDpanel.Request, response: LEDpanel.Response):\n        msg = BatStatus()\n\n        if (request.lbit3):\n            msg.led3 = 1\n        else:\n            msg.led3 = 0\n\n        self.publisher_.publish(msg)\n        self.get_logger().info(f\"{msg.led1} | {msg.led2} | {msg.led3}\")\n\n        response.success = True\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)   \n    LED_panel_node = MyPanel()\n    rclpy.spin(LED_panel_node) \n    rclpy.shutdown()\n\nif __name__ == \"__main__\":  \n    main()\n</code></pre>"},{"location":"Tareas/Task_7/#service-callback-behavior-set_status","title":"Service callback behavior (<code>set_status</code>)","text":"<p>When the service receives a request:</p> <ul> <li>A <code>BatStatus</code> message is created.</li> <li>The requested LED bit is translated into a <code>0/1</code> value in the corresponding <code>msg.ledX</code> field.</li> <li>The message is published to <code>/led_panel_state</code>.</li> <li>A logger prints a simple \u201cpanel visualization\u201d in the terminal (useful as a lightweight debugger).</li> <li><code>response.success</code> is set to <code>True</code> and returned to the client.</li> </ul> <p>For simplicity, the callback only evaluates <code>request.lbit3</code>, meaning the logic toggles only the least significant bit (LED 3). LEDs 1 and 2 remain available in the interface design but are not used in the current implementation.</p>"},{"location":"Tareas/Task_7/#node-2-battery-node-service-client-battery-simulation","title":"Node 2 \u2014 Battery Node (Service Client + Battery Simulation)","text":"<p>The <code>Battery_node</code> simulates battery life and triggers LED changes by calling the <code>/set_led</code> service.</p> <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom er_interfaces.srv import LEDpanel\nfrom functools import partial\n\nclass MyBat(Node):\n    def __init__(self):\n        super().__init__(\"Battery_node\") #Only identification          \n        self.client = self.create_client(LEDpanel,\"set_led\") #Service type, Service name\n\n        self.level = 100\n        self.create_timer(0.1, self.bat_level)\n\n    def call_status_alert(self, lbit3: bool):\n        while not self.client.wait_for_service(timeout_sec = 1.0):\n            self.get_logger().info(\"Server not available\")\n\n        request = LEDpanel.Request()\n        request.lbit3 = lbit3\n\n        self.future = self.client.call_async(request)   #asyncronous request\n        self.future.add_done_callback(partial(self.add_status_alert, request))\n\n    def add_status_alert(self, request: LEDpanel.Request, future):\n        response = future.result()\n        self.get_logger().info(f\"S: {response.success}, lbit3={request.lbit3}\")\n\n    def bat_level(self):\n        self.level -= 1\n        if (self.level == 60):\n            self.call_status_alert(False)\n        elif (self.level == 0): \n            self.level = 100\n            self.call_status_alert(True)\n\n\ndef main(args=None):\n    rclpy.init(args=args)   \n    Battery_node = MyBat()\n    rclpy.spin(Battery_node) \n    rclpy.shutdown()\n\nif __name__ == \"__main__\":  \n    main()\n</code></pre>"},{"location":"Tareas/Task_7/#service-call-workflow-call_status_alert-add_status_alert","title":"Service-call workflow (<code>call_status_alert</code> + <code>add_status_alert</code>)","text":"<ul> <li>Wait for server: <code>call_status_alert()</code> uses <code>wait_for_service()</code> to ensure <code>/set_led</code> is available (prints a message if not).</li> <li>Build request: creates <code>LEDpanel.Request()</code> and assigns <code>request.lbit3</code> from the input boolean (<code>True</code> = ON, <code>False</code> = OFF).</li> <li>Send asynchronously: calls <code>call_async(request)</code> so the node keeps running while the request is processed.</li> <li>Handle response: <code>add_status_alert()</code> retrieves <code>future.result()</code> and logs <code>success</code> plus the requested <code>lbit3</code> value for verification.</li> </ul>"},{"location":"Tareas/Task_7/#battery-simulation-approach","title":"Battery simulation approach","text":"<p>A timer runs every 100 ms (0.1 s) and executes a battery update function:</p> <ul> <li><code>self.level</code> starts at 100</li> <li>Each timer tick decrements the level by 1</li> <li>When specific thresholds are reached, the node sends a service request to the LED panel</li> </ul> <p>This timer-driven logic emulates a battery discharge/charge cycle without requiring real sensor input. The thresholds act as \u201cevents\u201d that trigger service calls. The battery node sends requests using an asynchronous service call (<code>call_async</code>). When the service returns a response the callback prints confirmation info (<code>success</code>) along with the request bit that was sent (<code>lbit3</code>), allowing quick validation that the interaction worked as expected.</p>"},{"location":"Tareas/Task_7/#terminal-commands","title":"Terminal Commands","text":"<ol> <li> <p>Run the nodes</p> <ul> <li> <p>LED_panel_node node <pre><code>ros2 run er_pkg LED_panel_node \n</code></pre></p> </li> <li> <p>Battery_node node <pre><code>ros2 run er_pkg Battery_node\n</code></pre></p> </li> </ul> </li> <li> <p>Verifying the System Graph and topic msg</p> <ul> <li>Topic msg <pre><code>ros2 topic echo /led_panel_state\n</code></pre></li> <li>System Graph <pre><code>rqt_graph\n</code></pre></li> </ul> </li> </ol>"},{"location":"Tareas/Task_7/#results-terminal-and-rqt_graph","title":"Results (Terminal and rqt_graph)","text":""},{"location":"Tareas/Task_8/","title":"Task 8","text":"<p>Home</p>"},{"location":"Tareas/Task_8/#ros-basics-capstone","title":"Ros Basics Capstone","text":""},{"location":"Tareas/Task_8/#1-instructions","title":"1.- Instructions","text":""},{"location":"Tareas/Task_8/#turtlesim-catch-them-all-project","title":"Turtlesim \u201cCatch Them All\u201d Project","text":"<p>You\u2019ll build a small multi-node ROS 2 application using turtlesim to visualize behavior.</p>"},{"location":"Tareas/Task_8/#how-to-work","title":"How to work","text":"<ol> <li> <p>Design first: draw the nodes, topics, services, and what each one does.</p> </li> <li> <p>Implement step-by-step.</p> </li> </ol>"},{"location":"Tareas/Task_8/#nodes","title":"Nodes","text":"<ol> <li> <p>turtlesim_node (from turtlesim package)</p> </li> <li> <p>turtle_controller (custom) \u2014 controls turtle1</p> </li> <li> <p>turtle_spawner (custom) \u2014 spawns and manages \u201calive\u201d turtles</p> </li> </ol> <p>Create a new package, e.g. turtlesim_catch_them_all, to store your nodes.</p>"},{"location":"Tareas/Task_8/#turtle_spawner-requirements","title":"turtle_spawner requirements","text":"<ul> <li> <p>Uses turtlesim services:</p> <ul> <li> <p>Calls /spawn to create turtles at random (x, y, theta)</p> </li> <li> <p>Calls /kill to remove turtles</p> </li> </ul> </li> <li> <p>Maintains an array/list of alive turtles (name + pose used at spawn time)</p> </li> <li> <p>Publishes alive turtles on /alive_turtles (TurtleArray)</p> </li> <li> <p>Provides service /catch_turtle (CatchTurtle) which:</p> <ul> <li> <p>Receives turtle name to catch</p> </li> <li> <p>Calls /kill</p> </li> <li> <p>Removes that turtle from the alive list</p> </li> <li> <p>Republishes updated /alive_turtles</p> </li> </ul> </li> <li> <p>Spawn coordinates: choose random x, y in [0.5, 10.5] (recommended) and theta in [0, 2\u03c0]. turtle_controller requirements:</p> <ul> <li> <p>Subscribes to /turtle1/pose</p> </li> <li> <p>Publishes velocity commands to /turtle1/cmd_vel</p> </li> <li> <p>Runs a control loop (timer, high rate) implementing a simplified P controller to reach a target turtle.</p> </li> <li> <p>Subscribes to /alive_turtles and selects a target turtle to catch.</p> </li> <li> <p>When turtle1 reaches the target (e.g. distance &lt; 0.3), calls /catch_turtle with the target name.</p> </li> </ul> </li> </ul>"},{"location":"Tareas/Task_8/#custom-interfaces-suggested","title":"Custom interfaces (suggested)","text":"<p>Create these in my_robot_interfaces:</p> <p>Turtle.msg:</p> <ul> <li> <p>string name</p> </li> <li> <p>float32 x</p> </li> <li> <p>float32 y</p> </li> <li> <p>float32 theta</p> </li> </ul> <p>TurtleArray.msg</p> <ul> <li> <p>Turtle[] turtles CatchTurtle.srv</p> </li> <li> <p>Request: string name</p> </li> <li> <p>Response: bool success</p> </li> </ul> <p>Parameters</p> <ul> <li> <p>/turtle_spawner</p> <ul> <li> <p>spawn_frequency (float)</p> </li> <li> <p>turtle_name_prefix (string)</p> </li> </ul> </li> <li> <p>/turtle_controller</p> </li> </ul>"},{"location":"Tareas/Task_8/#suggested-implementation-steps","title":"Suggested implementation steps","text":"<ol> <li> <p>Controller basics: subscribe to /turtle1/pose, implement control loop to reach an arbitrary fixed goal, publish /turtle1/cmd_vel.</p> </li> <li> <p>Spawner basics: timer spawns turtles at a rate by calling /spawn.</p> </li> <li> <p>Alive list + topic: spawner maintains list and publishes /alive_turtles; controller subscribes and targets the first turtle.</p> </li> <li> <p>Catch service: controller calls /catch_turtle when close; spawner kills turtle, updates list, republishes.</p> </li> <li> <p>Launch + params: create YAML + launch file to start all three nodes.</p> </li> </ol>"},{"location":"Tareas/Task_8/#2-turtle-sim-node","title":"2.- turtle sim node","text":"<p>We don't have to create this node, this ons already exist and we will only use it to extract infromation like pose, turtle names, kill and spawn.</p> <p>For calling this node we will put on the ubuntu terminal the next:</p> <pre><code>ros2 run turtlesim turtlesim_node\n</code></pre> <p></p>"},{"location":"Tareas/Task_8/#3-msg-and-srv-files-interfaces","title":"3.- msg and srv files (interfaces)","text":"<p>Before creating the nodes we will make the 3 files that act like our interfaces for saving information.</p> <p>TurtleArray.msg</p> <p>Save the name of the turtles spawned so that later the function kill can use them to make the kill action. Turtle is theh type of data and turtles the name of the sapawned turtles.</p> <pre><code>Turtle[] turtles\n</code></pre> <p>Turtle.msg</p> <p>Save the position of the turtle1 to later use it to move the turtle1 next to the other turtles.</p> <pre><code>string name\nfloat32 x\nfloat32 y\n</code></pre> <p>CatchTurtle.srv</p> <p>Compares and verify that the turtle that we wanted was the one that we caught.</p> <pre><code>string turtle_name\n---\nstring caught_turtle\n</code></pre>"},{"location":"Tareas/Task_8/#4-turtle_controller","title":"4.- turtle_controller","text":""},{"location":"Tareas/Task_8/#libraries-imported","title":"Libraries imported","text":"<p>Importing Modules and Packages. This were  extracted from turtlesim, python and a package that you must have to create to make the previos interfaces.</p> <pre><code>#!/usr/bin/env python3\n\nfrom turtle import distance\n\nimport rclpy\nfrom rclpy.node import Node\nimport math\nimport numpy as np\n\nfrom turtlesim.msg import Pose\nfrom geometry_msgs.msg import Twist\nfrom joseph_interfaces.msg import TurtleArray \nfrom joseph_interfaces.srv import CatchTurtle\n</code></pre>"},{"location":"Tareas/Task_8/#define-the-name-of-the-node-and-the-functions","title":"Define the name of the node and the functions","text":"<p>Node name: TurtleController</p> <pre><code>class TurtleController(Node):\n</code></pre> <p>functions:</p> <p>def init(self):</p> <p>Initialize the node and establish how it will communicate with others.</p> <ul> <li> <p>State Variables: Define x_target, y_target, and pose as None to ensure the robot doesn't move until it receives real data.</p> </li> <li> <p>Subscribers: Listen to turtle1/pose to find out the robot's location.</p> </li> <li> <p>Listen to alive_turtles to receive the list of available targets.</p> </li> <li> <p>Publisher: Create the turtle1/cmd_vel channel to send move commands.</p> </li> <li> <p>Client: Create a client for the catch_turtle service, which is the action of \"killing\" or eliminating the target turtle.</p> </li> </ul> <pre><code>    def __init__(self):\n        super().__init__('turtle_controller')\n        self.x_target = None\n        self.y_target = None\n        self.target_name = None # Added initialization\n        self.pose = None\n\n        self.pose_subscriber = self.create_subscription(Pose, 'turtle1/pose', self.pose_callback, 10)\n        self.cmd_vel_publisher = self.create_publisher(Twist, 'turtle1/cmd_vel', 10)\n        self.alive_subscriber = self.create_subscription(TurtleArray, 'alive_turtles', self.alive_callback, 10)\n        self.client_catch = self.create_client(CatchTurtle, 'catch_turtle')\n\n        self.is_catching = False\n        self.accumulated_error = 0\n        self.get_logger().info('Turtle Controller Node has been started.')\n</code></pre> <p>def pose_callback(self, msg):</p> <p>This logic runs repeatedly each time the main turtle reports its position. It contains the following control logic:</p> <ul> <li> <p>Error calculation: Calculates the distance and angle needed to reach the target using arctan\u00b2 and hypot.</p> </li> <li> <p>Angle normalization: The line (angle_error + np.pi) % (2 * np.pi) - np.pi is a funtion to turn degrees to radians (avoiding unnecessary turns greater than 180\u00b0).</p> </li> </ul> <p>Here is how the logic works:</p> <ul> <li> <p>If the distance is less than 0.3, the turtle stops and calls for capture.</p> </li> <li> <p>If the angle error is large, the turtle stops and only rotates on its own axis.</p> </li> <li> <p>If the angle is correct, the turtle moves forward using PI (Proportional-Integral) control to adjust its linear speed.</p> </li> </ul> <pre><code>def pose_callback(self, msg):\n        self.pose = msg\n\n        # Safety check: Wait for a target to be assigned\n        if self.x_target is None:\n            return\n\n        twist = Twist()\n        dy = self.y_target - msg.y\n        dx = self.x_target - msg.x\n        target_angle = np.arctan2(dy, dx)\n\n        angle_error = target_angle - msg.theta\n        angle_error = (angle_error + np.pi) % (2 * np.pi) - np.pi\n        distance = math.hypot(dx, dy)\n\n        if distance &lt;= 0.3:\n            # Arrived! Stop and reset\n            twist.linear.x = 0.0\n            twist.angular.z = 0.0\n            self.accumulated_error = 0\n            self.get_logger().info(f\"Target {self.target_name} reached!\")\n            # TODO: Add catch service call here\n            if not self.is_catching:\n                self.is_catching = True\n                self.call_catch_turtle_service(self.target_name)\n\n\n\n        elif abs(angle_error) &lt;= 0.3:\n            # Facing target: Move forward\n            self.accumulated_error += distance\n            ki_linear = 0.01\n            kp_linear = 2.0\n            twist.linear.x = (kp_linear * distance) + (ki_linear * self.accumulated_error)\n            twist.angular.z = 0.0\n        else:\n            # Wrong way: Rotate in place\n            twist.linear.x = 0.0\n            twist.angular.z = 2.0 * angle_error\n\n        self.cmd_vel_publisher.publish(twist)\n</code></pre> <p>def call_catch_turtle_service(self, turtle_name):</p> <p>It is activated each time the Spawner node publishes the list of live turtles.</p> <ul> <li> <p>Nearest Neighbor: It traverses the entire list of turtles (msg.turtles) and calculates which one is closest to the turtle1 current position.</p> </li> <li> <p>Assignment: If it finds a turtle# and the turtle1 is not busy capturing another (if not self.is_catching), it updates the target coordinates (x_target, y_target).</p> </li> </ul> <pre><code>def call_catch_turtle_service(self, turtle_name):\n        request = CatchTurtle.Request()\n        request.turtle_name = turtle_name\n        future = self.client_catch.call_async(request)\n        future.add_done_callback(self.callback_catch_turtle)\n</code></pre> <p>def callback_catch_turtle(self, future):</p> <p>It's a helper function for making the service call asynchronously, preparing the request with the name of the turtle we want to delete.</p> <ul> <li> <p>Uses call_async so the code doesn't freeze while waiting for the other node to respond.</p> </li> <li> <p>Adds a callback that will only be triggered when the service confirms the turtle has died.</p> </li> </ul> <pre><code>def callback_catch_turtle(self, future):\n        try:\n            response = future.result()\n            self.get_logger().info(f\"Turtle {response.caught_turtle} has been caught!\")\n\n            # Reset our state\n            self.is_catching = False\n            self.x_target = None\n            self.y_target = None\n        except Exception as e:\n            self.get_logger().error(f\"Service call failed: {e}\")\n</code></pre> <p>def alive_callback(self, msg):</p> <p>It only runs when CathTurtle service responds.</p> <p>Prints to the terminal that the turtle was successfully captured and reset to set is_catching to False and clears the targets. This tells the node that it is now free to search for the next turtle in the list.</p> <pre><code>def alive_callback(self, msg):\n        # Safety check: Wait until we know our own position\n        if self.pose is None or len(msg.turtles) == 0:\n            return\n\n        closest_turtle = None\n        min_dist = float('inf')\n\n        for turtle in msg.turtles:\n            dist = math.hypot(turtle.x - self.pose.x, turtle.y - self.pose.y)\n            if dist &lt; min_dist:\n                min_dist = dist\n                closest_turtle = turtle\n\n        if closest_turtle is not None:\n            if not self.is_catching:  # Only update target if we're not currently catching\n                self.x_target = closest_turtle.x\n                self.y_target = closest_turtle.y\n                self.target_name = closest_turtle.name\n</code></pre>"},{"location":"Tareas/Task_8/#keep-the-node-on-loop-and-activate-it","title":"Keep the node on loop and activate it","text":"<p><pre><code>def main(args=None):\n    rclpy.init(args=args)\n    node = TurtleController()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> To run it we will have to put on the ubuntu terminal this:</p> <pre><code>ros2 run myrobot_pkg turtle_controller\n</code></pre> <p></p> <p>Complete code</p> <pre><code>#!/usr/bin/env python3\n\nfrom turtle import distance\n\nimport rclpy\nfrom rclpy.node import Node\nimport math\nimport numpy as np\n\nfrom turtlesim.msg import Pose\nfrom geometry_msgs.msg import Twist\nfrom joseph_interfaces.msg import TurtleArray\nfrom joseph_interfaces.srv import CatchTurtle\n\nclass TurtleController(Node):\n    def __init__(self):\n        super().__init__('turtle_controller')\n        self.x_target = None\n        self.y_target = None\n        self.target_name = None # Added initialization\n        self.pose = None\n\n        self.pose_subscriber = self.create_subscription(Pose, 'turtle1/pose', self.pose_callback, 10)\n        self.cmd_vel_publisher = self.create_publisher(Twist, 'turtle1/cmd_vel', 10)\n        self.alive_subscriber = self.create_subscription(TurtleArray, 'alive_turtles', self.alive_callback, 10)\n        self.client_catch = self.create_client(CatchTurtle, 'catch_turtle')\n\n        self.is_catching = False\n        self.accumulated_error = 0\n        self.get_logger().info('Turtle Controller Node has been started.')\n\n    def pose_callback(self, msg):\n        self.pose = msg\n\n        # Safety check: Wait for a target to be assigned\n        if self.x_target is None:\n            return\n\n        twist = Twist()\n        dy = self.y_target - msg.y\n        dx = self.x_target - msg.x\n        target_angle = np.arctan2(dy, dx)\n\n        angle_error = target_angle - msg.theta\n        angle_error = (angle_error + np.pi) % (2 * np.pi) - np.pi\n        distance = math.hypot(dx, dy)\n\n        if distance &lt;= 0.3:\n            # Arrived! Stop and reset\n            twist.linear.x = 0.0\n            twist.angular.z = 0.0\n            self.accumulated_error = 0\n            self.get_logger().info(f\"Target {self.target_name} reached!\")\n            # TODO: Add catch service call here\n            if not self.is_catching:\n                self.is_catching = True\n                self.call_catch_turtle_service(self.target_name)\n\n\n\n        elif abs(angle_error) &lt;= 0.3:\n            # Facing target: Move forward\n            self.accumulated_error += distance\n            ki_linear = 0.01\n            kp_linear = 2.0\n            twist.linear.x = (kp_linear * distance) + (ki_linear * self.accumulated_error)\n            twist.angular.z = 0.0\n        else:\n            # Wrong way: Rotate in place\n            twist.linear.x = 0.0\n            twist.angular.z = 2.0 * angle_error\n\n        self.cmd_vel_publisher.publish(twist)\n\n    def call_catch_turtle_service(self, turtle_name):\n        request = CatchTurtle.Request()\n        request.turtle_name = turtle_name\n        future = self.client_catch.call_async(request)\n        future.add_done_callback(self.callback_catch_turtle)\n\n    def callback_catch_turtle(self, future):\n        try:\n            response = future.result()\n            self.get_logger().info(f\"Turtle {response.caught_turtle} has been caught!\")\n\n            # Reset our state\n            self.is_catching = False\n            self.x_target = None\n            self.y_target = None\n        except Exception as e:\n            self.get_logger().error(f\"Service call failed: {e}\")\n\n    def alive_callback(self, msg):\n        # Safety check: Wait until we know our own position\n        if self.pose is None or len(msg.turtles) == 0:\n            return\n\n        closest_turtle = None\n        min_dist = float('inf')\n\n        for turtle in msg.turtles:\n            dist = math.hypot(turtle.x - self.pose.x, turtle.y - self.pose.y)\n            if dist &lt; min_dist:\n                min_dist = dist\n                closest_turtle = turtle\n\n        if closest_turtle is not None:\n            if not self.is_catching:  # Only update target if we're not currently catching\n                self.x_target = closest_turtle.x\n                self.y_target = closest_turtle.y\n                self.target_name = closest_turtle.name\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TurtleController()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"Tareas/Task_8/#5-turtle_spawner","title":"5.- turtle_spawner","text":""},{"location":"Tareas/Task_8/#libraries-imported_1","title":"Libraries imported","text":"<p>Importing Modules and Packages. This were  extracted from turtlesim, python and a package that you must have to create to make the previos interfaces.</p> <pre><code>#mp!/usr/bin/env python3\n\nfrom random import uniform\n\n\n\nimport rclpy\n\nfrom rclpy.node import Node\n\nfrom turtlesim.srv import Spawn\nfrom turtlesim.srv import Kill\n\nfrom joseph_interfaces.msg import Turtle\nfrom joseph_interfaces.msg import TurtleArray\nfrom joseph_interfaces.srv import CatchTurtle\n</code></pre>"},{"location":"Tareas/Task_8/#define-the-name-of-the-node-and-the-functions_1","title":"Define the name of the node and the functions","text":"<p>Node name: TurtleSpawner</p> <pre><code>class TurtleSpawner(Node):\n</code></pre> <p>functions:</p> <p>def init(self):</p> <p>Configure the necessary tools to manage the turtle ecosystem:</p> <ul> <li> <p>Service Clients: Create two clients (spawn and kill) to communicate directly with the original turtlesim node.</p> </li> <li> <p>Timer: Set a timer that automatically calls the spawn_turtle function every 2.0 seconds.</p> </li> <li> <p>Publisher: Create the alive_turtles topic. This is vital because this is where the Controller learns which turtles are being targeted.</p> </li> <li> <p>Service Server: Create the catch_turtle service, this node provides the service that the controller uses when it encounters a turtle.</p> </li> </ul> <pre><code>def __init__(self):\n        super().__init__('turtle_spawner')\n        self.spawn_client= self.create_client(Spawn, 'spawn')\n        self.kill_client= self.create_client(Kill, 'kill')\n        self.get_logger().info('Turtle Spawner Node has been started.')\n        self.create_timer(2.0, self.spawn_turtle) #para bajar tiempo de aparicion\n        self.alive_turtles = []\n        self.alive_turtles_publisher= self.create_publisher (TurtleArray, 'alive_turtles', 10)\n        self.server_catch = self.create_service(CatchTurtle, 'catch_turtle', self.catch_turtle_callback)\n</code></pre> <p>def spawn_turtle(self):</p> <p>Generate the data for a new turtle:</p> <ul> <li> <p>Use uniform(0.5, 10.5) to choose a random position within the visible limits of the turtlesim window.</p> </li> <li> <p>Send an asynchronous request to the turtlesim service to physically display a turtle on the screen.</p> </li> <li> <p>Temporarily store the x and y coordinates so they can be recalled when the turtle officially appears.</p> </li> </ul> <pre><code>def spawn_turtle(self):\n        request = Spawn.Request()\n        request.x = uniform(0.5, 10.5)\n        request.y = uniform(0.5, 10.5)\n        request.theta = uniform(0, 3.14159)\n        future = self.spawn_client.call_async(request)\n        future.add_done_callback(self.spawn_callback)\n        self.last_spawn_x = request.x\n        self.last_spawn_y = request.y\n</code></pre> <p>def spawn_callback(self, future):</p> <p>Runs when Turtlesim confirms the turtle has been created:</p> <ul> <li> <p>Registration: Creates a Turtle-type message (from your custom interfaces) with the name Turtlesim assigned and the saved coordinates.</p> </li> <li> <p>Living List: Adds this new turtle to the self.alive_turtles list.</p> </li> <li> <p>Notification: Publishes the updated list to the alive_turtles topic so the Controller knows there's a new target on the map.</p> </li> </ul> <pre><code>def spawn_callback(self, future):\n        try:\n            response = future.result()\n            self.get_logger().info(f'Turtle spawned with name: {response.name}')\n            Turtle_msg = Turtle()\n            Turtle_msg.name = response.name\n            Turtle_msg.x = self.last_spawn_x\n            Turtle_msg.y = self.last_spawn_y\n            self.alive_turtles.append(Turtle_msg)\n\n            # 1. Create the 'envelope' (The Array Message)\n            msg = TurtleArray()\n            # 2. Put your 'storage box' (the list) into the envelope's 'turtles' field\n            msg.turtles = self.alive_turtles\n            # 3. Mail it!\n            self.alive_turtles_publisher.publish(msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Failed to spawn turtle: {e}')\n</code></pre> <p>def catch_turtle_callback (self, request, response):</p> <p>Coordinates the removal:</p> <ul> <li>List Cleanup: Uses a Python list comprehension ([t for t in .. if t.name != ..]) to remove the captured turtle from the program's memory.</li> </ul> <p>-Update: Immediately publishes the updated turtle list (now without the dead turtle) so that no one else tries to capture it.</p> <ul> <li> <p>Kill Call: Sends the command to the Turtlesim /kill service to visually remove the turtle from the screen.</p> </li> <li> <p>Response: Confirms to the Controller that the turtle was successfully processed.</p> </li> </ul> <pre><code>def catch_turtle_callback (self, request, response): \n            response.caught_turtle = request.turtle_name\n            self.alive_turtles = [t for t in self.alive_turtles if t.name != request.turtle_name]\n            TurtleArray_msg = TurtleArray()\n            TurtleArray_msg.turtles = self.alive_turtles\n            self.alive_turtles_publisher.publish(TurtleArray_msg)\n            Kill_request = Kill.Request()\n            Kill_request.name = request.turtle_name\n            future = self.kill_client.call_async(Kill_request)\n            future.add_done_callback(self.kill_callback)\n            return response\n</code></pre> <p>def kill_callback(self, future):</p> <p>Checks if the call to the Turtlesim \"kill\" service completed successfully. If there was an error, it reports it in the log so that it appears in the terminal.</p> <pre><code>def kill_callback(self, future):\n        try:\n            future.result()\n        except Exception as e:\n            self.get_logger().error(f\"Kill service call failed: {e}\")\n</code></pre>"},{"location":"Tareas/Task_8/#keep-the-node-on-loop-and-activate-it_1","title":"Keep the node on loop and activate it","text":"<p><pre><code>def main(args=None):\n    rclpy.init(args=args)\n    node = TurtleSpawner() # Initialize your class\n    rclpy.spin(node)       # Keep the node running\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <pre><code>ros2 run myrobot_pkg turtle_spawner\n</code></pre></p> <p></p> <p>Here is the complete code:</p> <pre><code>#mp!/usr/bin/env python3\n\nfrom random import uniform\n\n\n\nimport rclpy\n\nfrom rclpy.node import Node\n\nfrom turtlesim.srv import Spawn\nfrom turtlesim.srv import Kill\n\nfrom joseph_interfaces.msg import Turtle\nfrom joseph_interfaces.msg import TurtleArray\nfrom joseph_interfaces.srv import CatchTurtle\n\nclass TurtleSpawner(Node):\n    def __init__(self):\n        super().__init__('turtle_spawner')\n        self.spawn_client= self.create_client(Spawn, 'spawn')\n        self.kill_client= self.create_client(Kill, 'kill')\n        self.get_logger().info('Turtle Spawner Node has been started.')\n        self.create_timer(2.0, self.spawn_turtle) #para bajar tiempo de aparicion\n        self.alive_turtles = []\n        self.alive_turtles_publisher= self.create_publisher (TurtleArray, 'alive_turtles', 10)\n        self.server_catch = self.create_service(CatchTurtle, 'catch_turtle', self.catch_turtle_callback)\n\n    def spawn_turtle(self):\n        request = Spawn.Request()\n        request.x = uniform(0.5, 10.5)\n        request.y = uniform(0.5, 10.5)\n        request.theta = uniform(0, 3.14159)\n        future = self.spawn_client.call_async(request)\n        future.add_done_callback(self.spawn_callback)\n        self.last_spawn_x = request.x\n        self.last_spawn_y = request.y\n\n    def spawn_callback(self, future):\n        try:\n            response = future.result()\n            self.get_logger().info(f'Turtle spawned with name: {response.name}')\n            Turtle_msg = Turtle()\n            Turtle_msg.name = response.name\n            Turtle_msg.x = self.last_spawn_x\n            Turtle_msg.y = self.last_spawn_y\n            self.alive_turtles.append(Turtle_msg)\n\n            # 1. Create the 'envelope' (The Array Message)\n            msg = TurtleArray()\n            # 2. Put your 'storage box' (the list) into the envelope's 'turtles' field\n            msg.turtles = self.alive_turtles\n            # 3. Mail it!\n            self.alive_turtles_publisher.publish(msg)\n\n        except Exception as e:\n            self.get_logger().error(f'Failed to spawn turtle: {e}')\n\n    def catch_turtle_callback (self, request, response): \n            response.caught_turtle = request.turtle_name\n            self.alive_turtles = [t for t in self.alive_turtles if t.name != request.turtle_name]\n            TurtleArray_msg = TurtleArray()\n            TurtleArray_msg.turtles = self.alive_turtles\n            self.alive_turtles_publisher.publish(TurtleArray_msg)\n            Kill_request = Kill.Request()\n            Kill_request.name = request.turtle_name\n            future = self.kill_client.call_async(Kill_request)\n            future.add_done_callback(self.kill_callback)\n            return response\n\n    def kill_callback(self, future):\n        try:\n            future.result()\n        except Exception as e:\n            self.get_logger().error(f\"Kill service call failed: {e}\")\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TurtleSpawner() # Initialize your class\n    rclpy.spin(node)       # Keep the node running\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"Tareas/Task_8/#6-cmakeliststxt","title":"6.- CMakeLists.txt","text":"<p>Add the 3 files of the interfaces to the rosidl_generate_interfaces(${PROJECT_NAME}</p> <pre><code>\"msg/Turtle.msg\"\n\"msg/TurtleArray.msg\"\n\"srv/CatchTurtle.srv\"\n</code></pre>"},{"location":"Tareas/Task_8/#7-packagexml","title":"7.- package.xml","text":"<p>Add the depend and test_depend to it's own necesary group, like the turtle sim or our interfaces.</p> <pre><code>  &lt;depend&gt;rclpy&lt;/depend&gt;\n  &lt;depend&gt;example_interfaces&lt;/depend&gt;\n  &lt;depend&gt;geometry_msgs&lt;/depend&gt;\n  &lt;depend&gt;functools&lt;/depend&gt;\n  &lt;depend&gt;threading&lt;/depend&gt;\n  &lt;depend&gt;joseph_interfaces&lt;/depend&gt;\n  &lt;depend&gt;turtlesim&lt;/depend&gt;\n\n  &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt;\n  &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt;\n</code></pre>"},{"location":"Tareas/Task_8/#8-setuppy","title":"8.- setup.py","text":"<p>Add the 2 names of the nodes that had been created on the entry_point</p> <pre><code>'turtle_controller= myrobot_pkg.turtle_controller:main',\n            'turtle_spawner= myrobot_pkg.turtle_spawner:main',\n</code></pre>"},{"location":"Tareas/Task_8/#9-launch-the-3-nodes","title":"9.- Launch the 3 nodes","text":"<p>For this part we will have to create another package, then in the folder launch  you will find create a file xml ours will be called app_launch.xml and then add on which node is the code and the name of your node.</p> <p><pre><code>&lt;launch&gt;\n    &lt;node pkg=\"turtlesim\" exec=\"turtlesim_node\"/&gt;\n    &lt;node pkg=\"myrobot_pkg\" exec=\"turtle_controller\"/&gt;\n    &lt;node pkg=\"myrobot_pkg\" exec=\"turtle_spawner\"/&gt;\n&lt;/launch&gt;\n</code></pre> Then you will have to save and colcon build, we will launch our 3 nodes with this line</p> <pre><code>ros2 launch myrobot_bringup app_launch.xml\n</code></pre> <p>Here is how it looks</p> <p></p>"},{"location":"Tareas/Task_8/#10-results-terminal-and-rqt_graph","title":"10.- Results (Terminal and rqt_graph)","text":"<p>Once the nodes are finished we can open with the launch line or we will open 4 ubuntu terminals in this order</p> <ol> <li>Run turtle sim.</li> </ol> <pre><code>ros2 run turtlesim turtlesim_node\n</code></pre> <ol> <li>Run the spawner.</li> </ol> <pre><code>ros2 run myrobot_pkg turtle_spawner\n</code></pre> <ol> <li>Run the controller.</li> </ol> <pre><code>ros2 run myrobot_pkg turtle_controller\n</code></pre> <ol> <li>Graph</li> </ol> <pre><code>rqt_graph\n</code></pre> <p>Now when we run first 2 nodes, the turtle sim terminal appears with new information about the turtles spawned.</p> <p></p> <p>This is the result while running the 4 terminals.</p> <p></p>"}]}